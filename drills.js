// 1.Big 0
// O(1) - time does not change no matter the # of people
// O(n) - you need go with each individual, operations # depends on the #
// of people
// 2. even
// O(1) - arithmetic, you only put one value, time is not dependent
// 3. are you here?
// O(n^2) - because of nested loops
// 4. Doubler
// O(n) going through every item, runtime is proportional to the size
// 5. Naive Search
// O(n) going through every item, runtime is proportional to the size
// 6. Creating Pairs
// O(n^2) - because of nested loops, going through each array increases
// the runtime to the power of
// 7. Compute the sequence
// returns the Fibonacci Sequence in an array
// O(n) - it needs to go through the entire array in order to find the
// result, the runtime is linear
// 8. Efficient search
// O(log(n)) - this is a binary search within a sorted array, the runtime would be
// logarithmic. it splits it in half each time and searches it only in 
// that half; therefore, it decreases/halves each time it runs through 
// the algorithm
// 9. Random element
//  O(1) - everytime it grabs one item from the array so it does not matter
// the length of the array
// 10. What am I?
// the function returns prime numbers
// O(n) - it needs to loop through until it finds whether the # is prime
// 11. Tower of Hanoi
let arr= [[arr1], [arr2], [arr3]]
function hanoi(arr){
    //base case would be when the order is achieved
    // 

}